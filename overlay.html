<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Recording</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      -webkit-app-region: drag;
      user-select: none;
      overflow: hidden;
    }

    /* Ultra-Compact Recording Overlay */
    .overlay {
      width: 280px;
      height: 60px;
      background: linear-gradient(135deg, rgba(20, 20, 25, 0.98), rgba(30, 30, 40, 0.98));
      backdrop-filter: blur(60px) saturate(180%);
      -webkit-backdrop-filter: blur(60px) saturate(180%);
      border-radius: 10px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.6),
        0 0 0 0.5px rgba(255, 255, 255, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      display: flex;
      flex-direction: column;
      padding: 8px 12px;
      gap: 6px;
      position: relative;
      overflow: hidden;
    }

    /* Gradient Accent Border */
    .overlay::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: linear-gradient(90deg, #00d4ff, #a855f7, #00d4ff);
      background-size: 200% 100%;
      animation: gradientShift 3s ease infinite;
    }

    @keyframes gradientShift {

      0%,
      100% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }
    }

    /* Top Row */
    .top-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 16px;
    }

    /* Mode Badge */
    .mode-badge {
      background: linear-gradient(135deg, #a855f7, #7c3aed);
      color: white;
      padding: 2px 7px;
      border-radius: 4px;
      font-size: 8px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      box-shadow: 0 2px 8px rgba(168, 85, 247, 0.4);
      display: none;
    }

    /* Timer */
    .timer {
      font-size: 10px;
      color: #999;
      font-weight: 700;
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.3px;
    }

    /* Close Button */
    .close-btn {
      -webkit-app-region: no-drag;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: rgba(255, 59, 48, 0.15);
      border: none;
      color: #ff3b30;
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .close-btn:hover {
      background: rgba(255, 59, 48, 0.25);
      transform: scale(1.1);
    }

    /* Waveform Canvas */
    #waveformCanvas {
      width: 100%;
      height: 22px;
      border-radius: 4px;
    }

    /* Time Left Row */
    .time-left-row {
      display: flex;
      align-items: center;
      gap: 5px;
      height: 10px;
    }

    .time-left-label {
      font-size: 7px;
      color: #666;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.4px;
      white-space: nowrap;
    }

    .time-left-bar-container {
      flex: 1;
      height: 3px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 2px;
      overflow: hidden;
    }

    .time-left-bar {
      height: 100%;
      background: linear-gradient(90deg, #00d4ff, #0099ff);
      border-radius: 2px;
      transition: width 1s linear, background 0.3s;
      box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
    }

    .time-left-text {
      font-size: 8px;
      color: #00d4ff;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
      text-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
    }

    /* Recording Pulse */
    .recording-pulse {
      position: absolute;
      top: 8px;
      right: 38px;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #ff3b30;
      box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7);
      animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }

    @keyframes pulse-ring {

      0%,
      100% {
        box-shadow: 0 0 0 0 rgba(255, 59, 48, 0.7);
      }

      50% {
        box-shadow: 0 0 0 5px rgba(255, 59, 48, 0);
      }
    }
  </style>
</head>

<body>
  <div class="overlay">
    <!-- Recording Pulse -->
    <div class="recording-pulse"></div>

    <!-- Top Row -->
    <div class="top-row">
      <div class="mode-badge" id="modeBadge">AI</div>
      <div class="timer" id="timer">0:00</div>
      <button class="close-btn" onclick="cancel()" title="Cancel [Esc]">✕</button>
    </div>

    <!-- Waveform Canvas -->
    <canvas id="waveformCanvas"></canvas>

    <!-- Time Left Row -->
    <div class="time-left-row">
      <div class="time-left-label">⏱️ LEFT</div>
      <div class="time-left-bar-container">
        <div class="time-left-bar" id="timeLeftBar"></div>
      </div>
      <div class="time-left-text" id="timeLeftText">...</div>
    </div>
  </div>

  <script src="utils.js"></script>
  <script>
    const { ipcRenderer } = require('electron');
    const canvas = document.getElementById('waveformCanvas');
    const ctx = canvas.getContext('2d');
    const modeBadge = document.getElementById('modeBadge');
    const timer = document.getElementById('timer');
    const timeLeftBar = document.getElementById('timeLeftBar');
    const timeLeftText = document.getElementById('timeLeftText');

    // Set canvas size for compact overlay
    const dpr = window.devicePixelRatio || 1;
    canvas.width = 256 * dpr;  // Compact width
    canvas.height = 22 * dpr;  // Compact height
    canvas.style.width = '256px';
    canvas.style.height = '22px';
    ctx.scale(dpr, dpr);

    let mode = 'standard';
    let audioContext;
    let analyser;
    let dataArray;
    let animationId;
    let startTime = Date.now();
    let maxRecordingTime = 2400;
    let usedTime = 0;

    // Load real values
    function loadRealValues() {
      try {
        const today = new Date().toISOString().split('T')[0];
        const stats = JSON.parse(localStorage.getItem('recordingStats') || '{}');

        if (stats.date === today) {
          usedTime = (stats.standardTime || 0) + (stats.rewriteTime || 0);
          console.log('Loaded:', usedTime);
        } else {
          usedTime = 0;
        }

        updateTimeLeft();
      } catch (err) {
        console.error('Error:', err);
        usedTime = 0;
        updateTimeLeft();
      }
    }

    // Initialize audio
    async function initAudio() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64;
        analyser.smoothingTimeConstant = 0.85;
        source.connect(analyser);

        dataArray = new Uint8Array(analyser.frequencyBinCount);
        drawWaveform();
      } catch (err) {
        console.error('Mic error:', err);
        drawFakeWaveform();
      }
    }

    // Shared bar rendering function for compact overlay
    function drawBars(values) {
      ctx.clearRect(0, 0, 256, 22);

      const barCount = 40;  // Fewer bars for compact width
      const barWidth = 3;   // Thinner bars
      const gap = 2.5;
      const centerY = 11;   // Center for 22px height

      for (let i = 0; i < barCount; i++) {
        const barHeight = Math.max(values[i], 2);

        const gradient = ctx.createLinearGradient(0, centerY - barHeight / 2, 0, centerY + barHeight / 2);
        if (mode === 'rewrite') {
          gradient.addColorStop(0, '#a855f7');
          gradient.addColorStop(1, '#7c3aed');
        } else {
          gradient.addColorStop(0, '#00d4ff');
          gradient.addColorStop(1, '#0099ff');
        }

        ctx.fillStyle = gradient;
        ctx.shadowBlur = 3;
        ctx.shadowColor = mode === 'rewrite' ? '#a855f7' : '#00d4ff';
        ctx.fillRect(i * (barWidth + gap), centerY - barHeight / 2, barWidth, barHeight);
      }

      updateTimer();
    }

    // Draw waveform from real audio (compact)
    function drawWaveform() {
      animationId = requestAnimationFrame(drawWaveform);
      analyser.getByteFrequencyData(dataArray);

      const values = [];
      for (let i = 0; i < 40; i++) {  // 40 bars for compact width
        const dataIndex = Math.floor(i * dataArray.length / 40);
        const value = dataArray[dataIndex] / 255;
        values.push(value * 18);  // Slightly smaller bars
      }

      drawBars(values);
    }

    // Fallback animation for compact overlay
    function drawFakeWaveform() {
      let frame = 0;
      function animate() {
        animationId = requestAnimationFrame(animate);

        const values = [];
        for (let i = 0; i < 40; i++) {  // 40 bars for compact width
          const value = (Math.sin(frame * 0.05 + i * 0.3) * 0.5 + 0.5) * 0.6;
          values.push(value * 16);  // Slightly smaller bars
        }

        drawBars(values);
        frame++;
      }
      animate();
    }

    // Update timer
    function updateTimer() {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      timer.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
      updateTimeLeft();
    }

    // Update time left
    function updateTimeLeft() {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const currentUsed = usedTime + elapsed;
      const remaining = maxRecordingTime - currentUsed;
      const percentage = (currentUsed / maxRecordingTime) * 100;

      timeLeftBar.style.width = Math.min(percentage, 100) + '%';
      timeLeftText.textContent = `${currentUsed}/${maxRecordingTime}s`;

      if (remaining < 60) {
        timeLeftBar.style.background = 'linear-gradient(90deg, #ff3b30, #cc0000)';
        timeLeftBar.style.boxShadow = '0 0 8px rgba(255, 59, 48, 0.5)';
        timeLeftText.style.color = '#ff3b30';
        timeLeftText.style.textShadow = '0 0 8px rgba(255, 59, 48, 0.5)';
      } else if (remaining < 300) {
        timeLeftBar.style.background = 'linear-gradient(90deg, #ffaa00, #ff8800)';
        timeLeftBar.style.boxShadow = '0 0 8px rgba(255, 170, 0, 0.5)';
        timeLeftText.style.color = '#ffaa00';
        timeLeftText.style.textShadow = '0 0 8px rgba(255, 170, 0, 0.5)';
      }
    }

    // Set mode
    ipcRenderer.on('set-mode', (_, m) => {
      mode = m;
      if (mode === 'rewrite') {
        modeBadge.style.display = 'block';
      }
    });

    // Cancel
    function cancel() {
      if (audioContext) audioContext.close();
      if (animationId) cancelAnimationFrame(animationId);
      window.close();
    }

    // Initialize
    loadRealValues();
    initAudio();

    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (audioContext) audioContext.close();
      if (animationId) cancelAnimationFrame(animationId);
    });
  </script>
</body>

</html>