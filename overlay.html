<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval'; script-src 'self' 'unsafe-inline' 'unsafe-eval';">
  <title>Recording</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', system-ui, sans-serif;
      -webkit-app-region: drag;
      user-select: none;
      overflow: hidden;
      background: transparent;
      /* PERFORMANCE BOOST: Hardware acceleration */
      transform: translateZ(0);
      backface-visibility: hidden;
      will-change: transform;
      /* PERFORMANCE BOOST: Disable text rendering optimizations for speed */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeSpeed;
    }

    /* ULTRA-FAST Pill-shaped overlay with hardware acceleration */
    .overlay {
      height: 40px;
      background: #1e293b;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      display: inline-flex;
      align-items: center;
      padding: 0 16px;
      gap: 10px;
      position: relative;
      overflow: hidden;
      /* PERFORMANCE BOOST: Hardware acceleration and compositing */
      transform: translateZ(0);
      backface-visibility: hidden;
      will-change: transform, opacity;
      /* PERFORMANCE BOOST: Force GPU layer */
      -webkit-transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      /* PERFORMANCE BOOST: Optimize rendering */
      contain: layout style paint;
    }

    /* Recording indicator - pulsing ring */
    .rec-indicator {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      width: 20px;
      height: 20px;
      position: relative;
    }

    .rec-ring {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #22c55e;
      position: absolute;
      animation: ringPulse 1.5s ease-in-out infinite;
    }

    .rec-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #22c55e;
    }

    .overlay.rewrite .rec-ring {
      border-color: #a855f7;
    }

    .overlay.rewrite .rec-dot {
      background: #a855f7;
    }

    @keyframes ringPulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    /* Label text */
    .rec-label {
      font-size: 13px;
      font-weight: 500;
      color: rgba(255, 255, 255, 0.9);
      white-space: nowrap;
    }

    /* Waveform - compact inline */
    .waveform {
      height: 20px;
      width: 60px;
      flex-shrink: 0;
    }

    #waveCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Timer badge */
    .timer {
      font-size: 12px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.7);
      font-variant-numeric: tabular-nums;
      background: rgba(255, 255, 255, 0.1);
      padding: 2px 8px;
      border-radius: 10px;
      flex-shrink: 0;
    }

    /* Entrance animation */
    .overlay {
      animation: slideIn 0.2s ease-out;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-4px); }
      to { opacity: 1; transform: translateY(0); }
    }
  </style>
</head>

<body>
  <div class="overlay" id="overlay">
    <div class="rec-indicator">
      <div class="rec-ring"></div>
      <div class="rec-dot"></div>
    </div>

    <span class="rec-label">Recording</span>

    <div class="waveform">
      <canvas id="waveCanvas"></canvas>
    </div>

    <div class="timer" id="timer">0:00</div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    const canvas = document.getElementById('waveCanvas');
    const ctx = canvas.getContext('2d');
    const timer = document.getElementById('timer');
    const overlay = document.getElementById('overlay');

    let mode = 'standard';
    let audioContext;
    let analyser;
    let dataArray;
    let animationId;
    let startTime = Date.now();
    let canvasW = 60;
    let canvasH = 20;

    // Setup canvas after DOM ready
    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvasW * dpr;
      canvas.height = canvasH * dpr;
      canvas.style.width = canvasW + 'px';
      canvas.style.height = canvasH + 'px';
      ctx.scale(dpr, dpr);
    }

    // Smooth bar heights (6 bars, mirrored to make 12)
    let barHeights = new Array(6).fill(2);

    // Initialize audio
    async function initAudio() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
        });
        audioContext = new AudioContext({ latencyHint: 'interactive' });
        const source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 64;
        analyser.smoothingTimeConstant = 0.85;
        source.connect(analyser);
        dataArray = new Uint8Array(analyser.frequencyBinCount);
        animate();
      } catch (err) {
        console.error('Mic error:', err);
        animateFake();
      }
    }

    // ULTRA-FAST Real audio animation with optimizations
    let frameCount = 0;
    function animate() {
      animationId = requestAnimationFrame(animate);
      analyser.getByteFrequencyData(dataArray);

      // Map frequency data to 6 bars (center has highest energy)
      for (let i = 0; i < 6; i++) {
        const idx = Math.floor((i / 6) * dataArray.length);
        const target = (dataArray[idx] / 255) * 16 + 2;
        barHeights[i] = barHeights[i] * 0.7 + target * 0.3;
      }

      drawBars();
      
      // PERFORMANCE BOOST: Update timer less frequently (every 10 frames = ~6 times per second)
      frameCount++;
      if (frameCount % 10 === 0) {
        updateTimer();
      }
    }

    // ULTRA-FAST Fake animation fallback with optimizations
    function animateFake() {
      let t = 0;
      let frameCount = 0;
      function loop() {
        animationId = requestAnimationFrame(loop);
        
        // PERFORMANCE BOOST: Update bars less frequently for fake animation
        if (frameCount % 2 === 0) {
          for (let i = 0; i < 6; i++) {
            // Center bars (i=0) are tallest, outer bars shorter
            const centerFactor = 1 - (i / 6) * 0.4;
            const target = (Math.sin(t * 0.06 + i * 0.5) * 6 + 10) * centerFactor;
            barHeights[i] = barHeights[i] * 0.8 + target * 0.2;
          }
          drawBars();
          t++;
        }
        
        // PERFORMANCE BOOST: Update timer less frequently
        frameCount++;
        if (frameCount % 10 === 0) {
          updateTimer();
        }
      }
      loop();
    }

    // ULTRA-FAST Draw mirrored bars with optimizations
    function drawBars() {
      // PERFORMANCE BOOST: Use faster clearRect
      ctx.clearRect(0, 0, canvasW, canvasH);

      const halfBars = 6; // 6 bars on each side
      const barWidth = 2;
      const gap = 3;
      const centerX = canvasW / 2;
      const centerY = canvasH / 2;

      const color = mode === 'rewrite' ? '#a855f7' : '#22c55e';
      
      // PERFORMANCE BOOST: Set fillStyle once outside loop
      ctx.fillStyle = color;

      // PERFORMANCE BOOST: Batch drawing operations
      ctx.beginPath();
      
      // Draw bars from center outward (mirrored left and right)
      for (let i = 0; i < halfBars; i++) {
        const h = Math.max(barHeights[i] * 0.6, 2);
        const offset = (i * (barWidth + gap)) + gap / 2;

        // Right side bar
        ctx.roundRect(centerX + offset, centerY - h / 2, barWidth, h, 1);

        // Left side bar (mirrored)
        ctx.roundRect(centerX - offset - barWidth, centerY - h / 2, barWidth, h, 1);
      }
      
      // PERFORMANCE BOOST: Fill all bars at once
      ctx.fill();
    }

    // Update timer
    function updateTimer() {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60);
      const secs = elapsed % 60;
      timer.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Set mode
    ipcRenderer.on('set-mode', (_, m) => {
      mode = m;
      overlay.classList.toggle('rewrite', m === 'rewrite');
    });

    // Status updates
    ipcRenderer.on('status', (_, status) => {
      timer.textContent = status;
    });

    // Error handling
    ipcRenderer.on('error', (_, errorMsg) => {
      timer.textContent = 'Error';
      timer.style.color = '#ef4444';
    });

    // Cancel recording
    function cancel() {
      if (audioContext) audioContext.close();
      if (animationId) cancelAnimationFrame(animationId);
      window.close();
    }

    // ESC to cancel
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        e.preventDefault();
        cancel();
      }
    });

    // Initialize
    setupCanvas();
    initAudio();

    // Cleanup
    window.addEventListener('beforeunload', () => {
      if (audioContext) audioContext.close();
      if (animationId) cancelAnimationFrame(animationId);
    });
  </script>
</body>

</html>
